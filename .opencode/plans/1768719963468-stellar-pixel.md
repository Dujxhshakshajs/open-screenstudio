# Bug Fix Plan: Webcam Not Trimmed in Export

## Issue

Export with edits exports the FULL video instead of the edited/trimmed version. The webcam overlay is not being trimmed to match the screen recording edits.

Looking at the FFmpeg filter from logs:

```
[0:v]trim=start=0:end=1.52...[v0];[0:v]trim=start=2.83:end=4.833...[v1];...concat...[vconcat]
[1:v]scale=378:-1[wc_scaled];[vscaled][wc_scaled]overlay=...[vout]
```

The screen video (`[0:v]`) is trimmed with `trim` filters, but the webcam (`[1:v]`) is used directly without trimming. This causes FFmpeg to use the webcam's full duration.

## Root Cause

The webcam video needs the same trim/concat filters applied as the main video, but currently it's only being scaled and overlaid without any trimming.

## File to Modify

| File                             | Change                                          |
| -------------------------------- | ----------------------------------------------- |
| `src-tauri/src/export/ffmpeg.rs` | Apply trim edits to webcam video before overlay |

---

## Implementation

### Fix: Apply trim filters to webcam video

**File:** `src-tauri/src/export/ffmpeg.rs` (lines 696-712)

**Current code:**

```rust
if let Some(wc_idx) = webcam_input_index {
    let webcam_width = (output_width as f64 * 0.125) as u32;
    let margin = 20;

    // Scale webcam video
    filter_parts.push(format!(
        "[{}:v]scale={}:-1[wc_scaled]",
        wc_idx, webcam_width
    ));

    // Overlay webcam on main video
    filter_parts.push(format!(
        "[vscaled][wc_scaled]overlay=W-w-{}:H-h-{}[vout]",
        margin, margin
    ));
}
```

**Fixed code:**

```rust
if let Some(wc_idx) = webcam_input_index {
    let webcam_width = (output_width as f64 * 0.125) as u32;
    let margin = 20;

    // Apply same trim/concat edits to webcam as main video
    // Build trim filters for each segment
    let mut wc_segment_labels = Vec::new();
    for (i, seg) in edits.segments.iter().enumerate() {
        let start_sec = seg.source_start_ms as f64 / 1000.0;
        let end_sec = seg.source_end_ms as f64 / 1000.0;
        let label = format!("wc{}", i);

        filter_parts.push(format!(
            "[{}:v]trim=start={}:end={},setpts=PTS-STARTPTS[{}]",
            wc_idx, start_sec, end_sec, label
        ));
        wc_segment_labels.push(format!("[{}]", label));
    }

    // Concat webcam segments if multiple
    let wc_concat_label = if wc_segment_labels.len() > 1 {
        filter_parts.push(format!(
            "{}concat=n={}:v=1:a=0[wcconcat]",
            wc_segment_labels.join(""),
            wc_segment_labels.len()
        ));
        "wcconcat"
    } else {
        // Single segment, use directly (strip brackets)
        &wc_segment_labels[0][1..wc_segment_labels[0].len()-1]
    };

    // Scale webcam video
    filter_parts.push(format!(
        "[{}]scale={}:-1[wc_scaled]",
        wc_concat_label, webcam_width
    ));

    // Overlay webcam on main video with 'shortest' to stop when main video ends
    filter_parts.push(format!(
        "[vscaled][wc_scaled]overlay=W-w-{}:H-h-{}:shortest=1[vout]",
        margin, margin
    ));
}
```

---

## Verification

1. Record a video with webcam
2. Split the timeline to create 2+ segments
3. Export
4. Verify:
   - Exported video duration matches edited duration (not full recording)
   - Webcam overlay is visible and synced with screen
   - Audio is trimmed correctly

---

# PREVIOUS: Webcam Support Added (Completed)

);

````

---

## Verification

1. Record a video with webcam enabled
2. Make some cuts/splits in the timeline
3. Click Export
4. Verify exported video has:
   - Screen recording with cuts applied
   - Webcam overlay in bottom-right corner
   - Audio tracks included

---

# PREVIOUS FIXES (Completed)

## Issue 1: Export Type Mismatch (FIXED)

1. **Export fails** with error: `invalid type: floating point '8866.667', expected u64`
2. **Video preview is laggy** during playback

---

## Issue 1: Export Type Mismatch

### Root Cause

The Rust backend expects `u64` (integers) for `sourceStartMs` and `sourceEndMs` in `ExportSegment`, but TypeScript sends floating-point numbers.

**Source of floats:** In `projectStore.ts`, when a slice is split:

```typescript
const sourceTimeAtSplit = slice.sourceStartMs + offsetInSlice * slice.timeScale;
// This produces float like 8866.667
````

**Conversion point:** `slicesToTrackEdits()` in `ExportDialog.tsx` passes values directly without rounding.

### Files to Modify

| File                                     | Change                                         |
| ---------------------------------------- | ---------------------------------------------- |
| `src/components/export/ExportDialog.tsx` | Round values in `slicesToTrackEdits()`         |
| `src/stores/projectStore.ts`             | Round values when splitting slices (defensive) |

### Fix

**`src/components/export/ExportDialog.tsx`** - Update `slicesToTrackEdits`:

```typescript
function slicesToTrackEdits(slices: Slice[]): TrackEdits {
  return {
    segments: slices.map(
      (s): ExportSegment => ({
        sourceStartMs: Math.round(s.sourceStartMs), // Round to integer
        sourceEndMs: Math.round(s.sourceEndMs), // Round to integer
        timeScale: s.timeScale ?? 1.0,
      }),
    ),
  };
}
```

**`src/stores/projectStore.ts`** - Update `splitTrack` helper (lines 472-494):

```typescript
const sourceTimeAtSplit = Math.round(
  slice.sourceStartMs + offsetInSlice * slice.timeScale,
);
```

---

## Issue 2: Video Preview Lag

### Root Causes Identified

1. **CRITICAL: `console.log` in animation loop** (`CursorOverlay.tsx` lines 108-117)
   - Called on every render during playback = performance killer

2. **State updates every frame** (`EditorView.tsx` lines 294-379)
   - `setCursorPosition()` and `setRecentClicks()` trigger React re-renders 60x/second

3. **useMemo recalculates every frame** (`EditorView.tsx`)
   - `sliceIndex`, `sourceTimeMs`, `currentLayout` depend on `currentTimeMs`

4. **WebcamOverlay effect runs every frame** (`WebcamOverlay.tsx` lines 75-86)

### Files to Modify

| File                                               | Change                              |
| -------------------------------------------------- | ----------------------------------- |
| `src/components/editor/overlays/CursorOverlay.tsx` | Remove console.log                  |
| `src/components/editor/EditorView.tsx`             | Optimize cursor/click state updates |

### Fix - Priority Order

**1. Remove console.log (CRITICAL - immediate fix):**

`src/components/editor/overlays/CursorOverlay.tsx` - Delete lines 108-117:

```typescript
// DELETE THIS:
console.log("CursorOverlay debug:", {
  position: { x: position.x, y: position.y, cursorId: position.cursorId },
  // ...
});
```

**2. Optimize cursor state updates (HIGH priority):**

In `EditorView.tsx`, use refs instead of state for cursor position during playback:

- Store cursor position in `useRef` instead of `useState`
- Only update React state at lower frequency (e.g., every 100ms) for UI display
- Use CSS transform with ref values directly for smooth cursor movement

---

## Verification

1. **Export fix:**
   - Split a slice in the timeline
   - Click Export
   - Should complete without type error

2. **Performance fix:**
   - Play video in editor
   - Video should play smoothly without stuttering
   - Check devtools - no console.log spam

---

## Implementation Order

1. Remove `console.log` in CursorOverlay (1 min)
2. Round values in `slicesToTrackEdits` (1 min)
3. Round values in `splitTrack` in projectStore (1 min)
4. Test export works
5. (Optional) Further optimize cursor state if still laggy

---

# Previous Plan: Audio Waveforms & Export with Edits

## Overview

Add two features to Open ScreenStudio:

1. **Audio Waveform Visualization** - Show waveforms in timeline tracks
   - Screen track → system audio waveform
   - Camera track → microphone audio waveform

2. **Export with Edits** - Apply trim/cut edits during export
   - Respect slice boundaries (sourceStartMs/sourceEndMs)
   - Handle speed changes (timeScale)
   - Proper audio sync

## Current State

**Existing infrastructure:**

- Timeline with Screen and Camera tracks (`src/components/editor/timeline/`)
- Slices with `sourceStartMs`, `sourceEndMs`, `timeScale` properties
- Audio files: `.m4a` format (AAC) at `recording-0-system.m4a` and `recording-0-mic.m4a`
- Export pipeline using FFmpeg (`src-tauri/src/export/`)
- Audio playback synced to video in `EditorView.tsx`

**What's missing:**

- Waveform visualization in timeline
- Export doesn't respect edits (trims/cuts)

---

## Architecture

### Feature 1: Audio Waveform Visualization

**Approach:** Use Rust + FFmpeg for waveform extraction (M4A/AAC has inconsistent Web Audio API support)

### Feature 2: Export with Edits

**Approach:** Use FFmpeg `filter_complex` with trim/concat filters (no temp files needed)

---

## Files to Create/Modify

### New Files

| File                                          | Purpose                          |
| --------------------------------------------- | -------------------------------- |
| `src-tauri/src/waveform/mod.rs`               | Waveform module exports          |
| `src-tauri/src/waveform/extractor.rs`         | FFmpeg-based peak extraction     |
| `src-tauri/src/commands/waveform.rs`          | Tauri command for waveform       |
| `src/components/editor/timeline/Waveform.tsx` | Canvas-based waveform renderer   |
| `src/stores/waveformStore.ts`                 | Zustand store for waveform cache |
| `src/types/waveform.ts`                       | TypeScript type definitions      |

### Modified Files

| File                                           | Changes                       |
| ---------------------------------------------- | ----------------------------- |
| `src-tauri/src/lib.rs`                         | Register waveform command     |
| `src-tauri/src/export/pipeline.rs`             | Add edit-aware export         |
| `src-tauri/src/export/ffmpeg.rs`               | Add filter_complex generation |
| `src/components/editor/timeline/SliceItem.tsx` | Integrate Waveform component  |
| `src/components/editor/timeline/Timeline.tsx`  | Pass audio paths to tracks    |
| `src/components/export/ExportDialog.tsx`       | Pass slice edits to export    |

---

## Implementation Phases

### Phase 1: Waveform Extraction (Rust)

**Goal:** Extract waveform peaks from audio files via FFmpeg

**Create `src-tauri/src/waveform/extractor.rs`:**

```rust
pub struct WaveformData {
    pub peaks: Vec<f32>,           // 0.0-1.0 normalized
    pub duration_ms: u64,
    pub samples_per_second: u32,   // Default: 50 peaks/sec
}

pub async fn extract_waveform(
    audio_path: &Path,
    samples_per_second: u32,
) -> Result<WaveformData, Error>
```

**Algorithm:**

1. Use FFmpeg to decode audio to raw PCM: `ffmpeg -i input.m4a -ac 1 -ar 8000 -f s16le -`
2. Get duration via ffprobe
3. Process samples into peaks (max absolute value per time bucket)
4. Normalize to 0.0-1.0 range

**Create Tauri command:**

```rust
#[tauri::command]
pub async fn get_waveform(audio_path: String, samples_per_second: Option<u32>) -> Result<WaveformData, String>
```

### Phase 2: Waveform UI (TypeScript/React)

**Goal:** Display waveforms in timeline slices

**Create `src/stores/waveformStore.ts`:**

```typescript
interface WaveformState {
  cache: Record<string, WaveformData>;
  loading: Record<string, boolean>;
  fetchWaveform: (audioPath: string) => Promise<WaveformData | null>;
}
```

**Create `src/components/editor/timeline/Waveform.tsx`:**

- Canvas-based renderer
- Props: `data`, `sourceStartMs`, `sourceEndMs`, `timeScale`, `width`, `height`, `color`
- Only render visible portion of waveform (respect trim)
- Mirrored waveform (extends up and down from center)

**Modify `SliceItem.tsx`:**

- Accept `audioPath` prop
- Fetch waveform on mount
- Render Waveform as background layer

**Modify `Timeline.tsx`:**

- Pass `systemAudioPath` to Screen track items
- Pass `micAudioPath` to Camera track items

### Phase 3: Export with Edits (Rust)

**Goal:** Apply trim/cut edits during export

**Create edit types in `src-tauri/src/export/types.rs`:**

```rust
pub struct ExportSegment {
    pub source_start_ms: u64,
    pub source_end_ms: u64,
    pub time_scale: f64,
}

pub struct TrackEdits {
    pub segments: Vec<ExportSegment>,
}
```

**Create filter_complex generator:**

- For each segment: `trim`, `setpts` (for speed), `atrim`, `asetpts`, `atempo`
- Concat multiple segments
- Handle timeScale with `setpts=PTS/{timeScale}` for video, `atempo` chain for audio

**Example filter for 2 segments:**

```
[0:v]trim=start=0:end=5,setpts=PTS-STARTPTS[v0];
[0:v]trim=start=10:end=15,setpts=PTS-STARTPTS[v1];
[0:a]atrim=start=0:end=5,asetpts=PTS-STARTPTS[a0];
[0:a]atrim=start=10:end=15,asetpts=PTS-STARTPTS[a1];
[v0][v1]concat=n=2:v=1:a=0[vconcat];
[a0][a1]concat=n=2:v=0:a=1[aconcat];
[vconcat]scale=1920:1080,fps=30[vout];
[aconcat]anull[aout]
```

### Phase 4: Export UI Integration

**Goal:** Connect UI to edit-aware export

**Modify `ExportDialog.tsx`:**

- Get `screenSlices` and `cameraSlices` from projectStore
- Convert slices to `TrackEdits` format
- Pass to `export_with_edits` command

**Helper function:**

```typescript
function slicesToTrackEdits(slices: Slice[]): TrackEdits {
  return {
    segments: slices.map((s) => ({
      sourceStartMs: s.sourceStartMs,
      sourceEndMs: s.sourceEndMs,
      timeScale: s.timeScale ?? 1.0,
    })),
  };
}
```

---

## Key Data Structures

### WaveformData (Rust → TypeScript)

```typescript
interface WaveformData {
  peaks: number[]; // 0.0-1.0 normalized
  durationMs: number;
  samplesPerSecond: number;
}
```

### ExportRequest (TypeScript → Rust)

```typescript
interface ExportRequest {
  projectPath: string;
  outputPath: string;
  screenEdits: TrackEdits;
  cameraEdits?: TrackEdits;
  settings: {
    width: number;
    height: number;
    fps: number;
    videoBitrate: string;
    audioBitrate: string;
  };
}
```

---

## Verification Plan

### Phase 1 Verification (Waveform Extraction)

- [ ] `cargo test` passes for waveform module
- [ ] Can extract peaks from test .m4a file
- [ ] Peaks are normalized 0.0-1.0
- [ ] Duration matches ffprobe output

### Phase 2 Verification (Waveform UI)

- [ ] `bun run build` passes
- [ ] Waveforms appear in Screen track (blue)
- [ ] Waveforms appear in Camera track (green)
- [ ] Trimming a slice shows correct waveform portion
- [ ] Waveform scales with zoom

### Phase 3 Verification (Export Edits)

- [ ] `cargo test` passes for filter_complex generation
- [ ] Export with single trimmed segment produces correct duration
- [ ] Export with multiple segments concatenates correctly
- [ ] Speed changes (timeScale != 1) work correctly
- [ ] Audio stays in sync with video

### Phase 4 Verification (E2E)

- [ ] Export dialog shows progress
- [ ] Exported video has correct cuts
- [ ] Exported video has correct audio
- [ ] Cancel export works

### Test Matrix

| Test Case   | Input                    | Expected Output  |
| ----------- | ------------------------ | ---------------- |
| Full export | 1 segment, full duration | Same as original |
| Simple trim | 1 segment, 10-50s        | 40s output       |
| Two cuts    | 0-2s, 5-7s segments      | 4s output        |
| Speed 2x    | 1 segment, timeScale=2   | Half duration    |
| Speed 0.5x  | 1 segment, timeScale=0.5 | Double duration  |

---

## Estimated Effort

- **Phase 1 (Waveform Rust)**: 2-3 hours
- **Phase 2 (Waveform UI)**: 3-4 hours
- **Phase 3 (Export Edits)**: 4-5 hours
- **Phase 4 (Export UI)**: 2-3 hours

**Total**: ~12-15 hours
