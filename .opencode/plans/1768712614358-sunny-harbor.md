# Export Backend Implementation Plan

## Status: FIXING WEBCAM OVERLAY ARTIFACTS

## Current Issues

### Issue 1: 4K Export still has encoding issues

CRF 1 fix didn't fully resolve the issue.

### Issue 2: Aspect Ratio Distortion

Video is "shrunk in Y axis" - this is because:

- **Source**: 3024x1964 (aspect ratio ~1.54:1, NOT 16:9)
- **4K preset**: 3840x2160 (16:9 aspect ratio)
- **Scaling**: `scale=3840:2160` FORCES 16:9, distorting the original

### Root Cause: Hardcoded Resolutions

The presets use hardcoded 16:9 resolutions that don't match the source aspect ratio.

**Current flow:**

1. Frontend sends hardcoded width/height (e.g., 3840x2160)
2. Backend scales source (3024x1964) to target (3840x2160)
3. This STRETCHES the video, breaking aspect ratio

**Correct approach:**

1. Calculate output dimensions that PRESERVE source aspect ratio
2. Scale proportionally based on a "max dimension" or "quality level"
3. Don't force specific resolutions that don't match source

---

## Fix Plan: Remove Hardcoded Resolutions, Preserve Aspect Ratio

### Core Principle

**Don't scale at all by default.** Export at source resolution. Only scale if user explicitly wants a different size.

### Approach: Simplify Export Options

Instead of hardcoded resolutions, use **quality presets** that determine:

1. CRF value (quality)
2. Encoding preset (speed)
3. Output format

Resolution should default to **source resolution** (no scaling), or use aspect-ratio-preserving scaling.

### Changes Required

#### 1. Backend: Remove forced scaling (ffmpeg.rs)

**Option A (Recommended): No scaling by default**

- If `options.width == 0` or matches source, don't add `-vf scale`
- Only scale if explicitly requested AND preserve aspect ratio

**Option B: Aspect-ratio-preserving scale**

```rust
// Use FFmpeg's aspect-ratio-preserving scale:
// scale=width:-1 (auto-calculate height to preserve aspect ratio)
// scale=-1:height (auto-calculate width)
// scale='min(3840,iw)':'min(2160,ih)':force_original_aspect_ratio=decrease
```

#### 2. Frontend: Change presets to not force resolution

Instead of:

```typescript
{
  resolution: "3840x2160";
} // Hardcoded, breaks aspect ratio
```

Use:

```typescript
{ maxWidth: 3840, quality: "high" }  // Scale down if larger, preserve aspect ratio
// OR
{ scaleFactor: 1.0, quality: "high" }  // 1.0 = source size, 0.5 = half size
```

#### 3. Add source resolution to export options

The backend should calculate the actual output dimensions based on:

- Source resolution (from decoder)
- Max dimensions (from user preference)
- Aspect ratio preservation

### Implementation Steps

#### Step 1: Simplify presets to not specify resolution (ExportDialog.tsx)

Change presets from hardcoded resolution to quality-based:

```typescript
const presets: ExportPreset[] = [
  {
    id: "original",
    name: "Original",
    icon: Monitor,
    format: "mp4",
    quality: "high",
    // No width/height - use source resolution
  },
  {
    id: "web-hd",
    name: "Web HD",
    icon: Globe,
    format: "mp4",
    quality: "high",
    maxHeight: 1080, // Scale down to max 1080p, preserve aspect ratio
  },
  {
    id: "4k",
    name: "4K",
    icon: Monitor,
    format: "mp4",
    quality: "lossless",
    // No scaling - export at source resolution with max quality
  },
];
```

#### Step 2: Update ExportOptions to support "no scaling" (types.rs)

```rust
pub struct ExportOptions {
    // Change width/height to Option<u32>
    // None means "use source resolution"
    pub width: Option<u32>,
    pub height: Option<u32>,
    // ... rest unchanged
}
```

#### Step 3: Fix encoder to handle "no scaling" (ffmpeg.rs)

```rust
// Only add -vf scale if BOTH width and height are specified
// AND they differ from source
if let (Some(w), Some(h)) = (options.width, options.height) {
    if w != source_width || h != source_height {
        // Use aspect-ratio-preserving scale
        args.extend([
            "-vf".to_string(),
            format!("scale={}:{}:force_original_aspect_ratio=decrease,pad={}:{}:(ow-iw)/2:(oh-ih)/2", w, h, w, h),
        ]);
    }
}
// If width/height not specified, NO scaling - output at source resolution
```

#### Step 4: Frontend sends source dimensions or "original" flag

When "Original" or "4K" preset is selected, don't send width/height to backend.
Backend uses source dimensions from the decoder.

### Verification

1. Run `bun run tauri:dev`
2. Make a recording (~10 seconds)
3. Export with each preset:
   - **Original**: Should export at exact source resolution (e.g., 3024x1964)
   - **Web HD**: Should scale to max 1080p height, preserving aspect ratio
   - **4K**: Should export at source resolution with high quality
4. Check each exported video:
   - Correct aspect ratio (not stretched/squished)
   - No encoding artifacts
   - Audio/video in sync

### Files to Modify

| File                                     | Changes                                           |
| ---------------------------------------- | ------------------------------------------------- |
| `src/components/export/ExportDialog.tsx` | Change presets, send optional dimensions          |
| `src-tauri/src/export/types.rs`          | Make width/height optional                        |
| `src-tauri/src/export/ffmpeg.rs`         | Handle no-scaling case, fix aspect ratio          |
| `src-tauri/src/export/pipeline.rs`       | Pass source dimensions when options don't specify |

| File                               | Changes                                                                                |
| ---------------------------------- | -------------------------------------------------------------------------------------- |
| `src-tauri/src/export/ffmpeg.rs`   | Add `fps` field to VideoDecoder, add `fps()` getter, add `source_fps` param to encoder |
| `src-tauri/src/export/pipeline.rs` | Get source FPS from decoder, pass to encoder                                           |

---

## Previous Work (Completed)

---

## UI Refactor Plan

### Current State

- `EditorLayout.tsx` has Editor/Export tabs
- `ExportView.tsx` is a full page component
- No header bar in editor, no Export button visible

### Target State (like ScreenStudio)

- **Single unified view**: Preview always visible
- **Header bar**: Project name on left, Export button (red) on top-right
- **Export dialog**: Modal that opens when clicking Export button
- **No tabs/pages**: Remove the tab navigation entirely

---

## Files to Modify

| File                                     | Changes                                         |
| ---------------------------------------- | ----------------------------------------------- |
| `src/App.tsx`                            | Change from `EditorLayout` back to `EditorView` |
| `src/components/editor/EditorView.tsx`   | Add header bar with Export button               |
| `src/components/export/ExportDialog.tsx` | **NEW** - Modal dialog for export               |

## Files to Delete

| File                                     | Reason                     |
| ---------------------------------------- | -------------------------- |
| `src/components/editor/EditorLayout.tsx` | No longer needed (no tabs) |
| `src/components/export/ExportView.tsx`   | Replace with ExportDialog  |

---

## Implementation Details

### Step 1: Create ExportDialog Component

Create `src/components/export/ExportDialog.tsx`:

```tsx
interface ExportDialogProps {
  isOpen: boolean;
  onClose: () => void;
}
```

Content from current ExportView, but:

- Wrap in a modal/dialog overlay
- Smaller, more compact layout
- Quick preset buttons at top
- Cancel button closes dialog

### Step 2: Update EditorView

Add a header bar at the top of EditorView:

```tsx
<div className="h-screen flex flex-col bg-[#1a1a1a]">
  {/* Header Bar */}
  <div className="flex items-center justify-between px-4 py-2 border-b border-border">
    <span className="text-sm text-muted-foreground">
      {project?.name || "Untitled Recording"}
    </span>
    <button
      onClick={() => setShowExportDialog(true)}
      className="flex items-center gap-2 bg-red-500 hover:bg-red-600 text-white px-4 py-1.5 rounded-lg text-sm font-medium"
    >
      <Download className="w-4 h-4" />
      Export
    </button>
  </div>
  {/* Main Preview Area - existing code */}
  ...
  {/* Export Dialog */}
  <ExportDialog
    isOpen={showExportDialog}
    onClose={() => setShowExportDialog(false)}
  />
</div>
```

### Step 3: Update App.tsx

Change back to render EditorView directly:

```tsx
// Render the editor view
return <EditorView />;
```

### Step 4: Delete Old Files

- Remove `EditorLayout.tsx`
- Remove `ExportView.tsx` (content moved to ExportDialog)

---

## Export Dialog Layout

Based on ScreenStudio reference image 2:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                    [X]  â”‚
â”‚  Video title                      ðŸ”’ Private           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  Only people you...   â”‚
â”‚  â”‚ Built-in Retina Display ... â”‚  [Toggle]             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â”‚                                                         â”‚
â”‚  Export to                                              â”‚
â”‚  [ðŸ“ File] [ðŸ“‹ Clipboard] [ðŸ”— Shareable] [...]         â”‚
â”‚                                                         â”‚
â”‚  Shareable links are always 1080p @ 60fps               â”‚
â”‚  Estimation - Export time 3 seconds                     â”‚
â”‚                                                         â”‚
â”‚  [Export & Share â†’]                        [Cancel]     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Simplified MVP version:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Export Video                                      [X]  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  Preset                                                 â”‚
â”‚  [Web HD] [Social] [4K] [GIF]                          â”‚
â”‚                                                         â”‚
â”‚  â˜ Use custom settings                                 â”‚
â”‚    (Format, Quality, Resolution, FPS dropdowns)        â”‚
â”‚                                                         â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  Duration: 5s | Format: MP4 | Resolution: 1920x1080   â”‚
â”‚                                                         â”‚
â”‚  [Cancel]                        [ðŸŽ¬ Export Video]     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

When exporting:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Exporting...                                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  Encoding video... 45%                                  â”‚
â”‚  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘                           â”‚
â”‚                                                         â”‚
â”‚  [Cancel]                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Verification

1. Run `bun run tauri:dev`
2. Make a recording
3. In the editor window:
   - Verify header bar shows with project name and red Export button
   - Click Export â†’ dialog opens
   - Select preset â†’ click Export Video
   - Progress shows in dialog
   - On complete, dialog shows success with "Open Folder" option
4. Verify export file is created and plays correctly

---

## Architecture

### Export Flow

```
Project Config
     â†“
Load Recording Bundle (video, audio, cursor data, webcam)
     â†“
Apply Cursor Smoothing (if enabled)
     â†“
Compose Frames (background + video + cursor + webcam)
     â†“
Encode to Output Format (MP4/WebM/GIF)
     â†“
Emit Progress Events
     â†“
Final File
```

### Two-Phase Approach

**Phase A: MVP Export (Core functionality)**

- Screen video + audio only
- Basic cursor overlay
- MP4 output

**Phase B: Full Export (Complete features)**

- All compositing layers
- All formats (WebM, GIF)
- Zoom ranges, time scaling

This plan covers **Phase A (MVP)** first.

---

## Files to Create

| File                               | Purpose                        |
| ---------------------------------- | ------------------------------ |
| `src-tauri/src/export/mod.rs`      | Module exports                 |
| `src-tauri/src/export/types.rs`    | Export options, progress types |
| `src-tauri/src/export/pipeline.rs` | Main export orchestration      |
| `src-tauri/src/export/ffmpeg.rs`   | FFmpeg command builder         |
| `src-tauri/src/commands/export.rs` | Tauri commands                 |

## Files to Modify

| File                                   | Changes                                          |
| -------------------------------------- | ------------------------------------------------ |
| `src-tauri/src/lib.rs`                 | Uncomment `pub mod export;`, register commands   |
| `src-tauri/src/commands/mod.rs`        | Add `pub mod export;`                            |
| `src/components/export/ExportView.tsx` | Replace simulated progress with real Tauri calls |

---

## Implementation Details

### Step 1: Types (`src-tauri/src/export/types.rs`)

```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum ExportFormat {
    Mp4,
    Webm,
    Gif,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum ExportQuality {
    Low,
    Medium,
    High,
    Lossless,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ExportOptions {
    pub format: ExportFormat,
    pub quality: ExportQuality,
    pub width: u32,
    pub height: u32,
    pub fps: u32,
    pub output_path: String,
    pub include_cursor: bool,
    pub include_webcam: bool,
    pub include_mic_audio: bool,
    pub include_system_audio: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ExportProgress {
    pub percent: f32,
    pub stage: ExportStage,
    pub current_frame: u64,
    pub total_frames: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum ExportStage {
    Preparing,
    SmoothingCursor,
    Encoding,
    Finalizing,
    Complete,
    Error { message: String },
}
```

### Step 2: FFmpeg Builder (`src-tauri/src/export/ffmpeg.rs`)

Build FFmpeg commands for different export scenarios.

**MVP Approach:** Use FFmpeg's `drawtext` or prepare cursor frames, then overlay using complex filter.

**Key FFmpeg Commands:**

1. **Simple re-encode with audio mix:**

```bash
ffmpeg -i screen.mp4 -i mic.m4a -i system.m4a \
  -filter_complex "[1:a][2:a]amix=inputs=2[audio]" \
  -map 0:v -map "[audio]" \
  -c:v libx264 -crf {crf} \
  -c:a aac -b:a 192k \
  output.mp4
```

2. **With cursor overlay (using image overlay per frame):**
   - Option A: Pre-render cursor frames to video, overlay
   - Option B: Use FFmpeg `movie` filter with cursor images
   - Option C: Frame-by-frame composition in Rust, pipe to FFmpeg

**Recommended: Option C** - Most control, consistent with existing pattern.

```rust
pub struct ExportEncoder {
    ffmpeg_stdin: ChildStdin,
    width: u32,
    height: u32,
    fps: u32,
}

impl ExportEncoder {
    pub fn new(options: &ExportOptions) -> Result<Self, ExportError> {
        let crf = match options.quality {
            ExportQuality::Low => 28,
            ExportQuality::Medium => 23,
            ExportQuality::High => 18,
            ExportQuality::Lossless => 0,
        };

        let mut cmd = Command::new("ffmpeg");
        cmd.args([
            "-y",
            "-f", "rawvideo",
            "-pix_fmt", "rgba",
            "-s", &format!("{}x{}", options.width, options.height),
            "-r", &options.fps.to_string(),
            "-i", "-",  // stdin for video frames
        ]);

        // Add audio inputs if available
        // ...

        cmd.args([
            "-c:v", "libx264",
            "-preset", "medium",
            "-crf", &crf.to_string(),
            "-pix_fmt", "yuv420p",
            "-movflags", "+faststart",
            &options.output_path,
        ]);

        // ...
    }

    pub fn write_frame(&mut self, rgba_data: &[u8]) -> Result<(), ExportError> {
        self.ffmpeg_stdin.write_all(rgba_data)?;
        Ok(())
    }
}
```

### Step 3: Export Pipeline (`src-tauri/src/export/pipeline.rs`)

```rust
pub struct ExportPipeline {
    project_dir: PathBuf,
    options: ExportOptions,
    cancel_flag: Arc<AtomicBool>,
}

impl ExportPipeline {
    pub async fn run<F>(&self, progress_callback: F) -> Result<(), ExportError>
    where
        F: Fn(ExportProgress) + Send + 'static,
    {
        // 1. Load recording bundle
        let bundle = self.load_bundle()?;
        progress_callback(ExportProgress { stage: Preparing, percent: 5.0, .. });

        // 2. Smooth cursor data
        let smoothed_cursor = if self.options.include_cursor {
            self.smooth_cursor(&bundle)?
        } else {
            vec![]
        };
        progress_callback(ExportProgress { stage: SmoothingCursor, percent: 10.0, .. });

        // 3. Open video decoder (FFmpeg to read screen.mp4)
        let mut decoder = VideoDecoder::open(&bundle.screen_video)?;

        // 4. Open encoder
        let mut encoder = ExportEncoder::new(&self.options)?;

        // 5. Process each frame
        let total_frames = decoder.frame_count();
        for frame_idx in 0..total_frames {
            if self.cancel_flag.load(Ordering::Relaxed) {
                return Err(ExportError::Cancelled);
            }

            // Decode frame
            let mut frame = decoder.read_frame()?;

            // Composite cursor overlay
            if let Some(cursor) = self.cursor_at_frame(frame_idx, &smoothed_cursor) {
                self.draw_cursor(&mut frame, &cursor, &bundle.cursor_images)?;
            }

            // Composite webcam (if enabled)
            // ...

            // Encode frame
            encoder.write_frame(&frame)?;

            let percent = 10.0 + (frame_idx as f32 / total_frames as f32) * 85.0;
            progress_callback(ExportProgress { stage: Encoding, percent, current_frame: frame_idx, total_frames });
        }

        // 6. Finalize
        encoder.finish()?;
        progress_callback(ExportProgress { stage: Complete, percent: 100.0, .. });

        Ok(())
    }
}
```

### Step 4: Tauri Commands (`src-tauri/src/commands/export.rs`)

```rust
use tauri::{AppHandle, Emitter, State};
use crate::export::{ExportOptions, ExportPipeline, ExportProgress};

#[tauri::command]
pub async fn start_export(
    app: AppHandle,
    project_dir: String,
    options: ExportOptions,
) -> Result<(), String> {
    let pipeline = ExportPipeline::new(project_dir.into(), options);

    // Run in background task
    tauri::async_runtime::spawn(async move {
        let result = pipeline.run(|progress| {
            let _ = app.emit("export-progress", progress);
        }).await;

        match result {
            Ok(_) => {
                let _ = app.emit("export-complete", ());
            }
            Err(e) => {
                let _ = app.emit("export-error", e.to_string());
            }
        }
    });

    Ok(())
}

#[tauri::command]
pub fn cancel_export(state: State<'_, ExportState>) -> Result<(), String> {
    state.cancel_flag.store(true, Ordering::Relaxed);
    Ok(())
}
```

### Step 5: Frontend Integration (`ExportView.tsx`)

```typescript
import { invoke } from "@tauri-apps/api/core";
import { listen } from "@tauri-apps/api/event";

const handleExport = async () => {
  setExportState("exporting");
  setProgress(0);

  // Listen for progress events
  const unlisten = await listen<ExportProgress>("export-progress", (event) => {
    setProgress(event.payload.percent);
  });

  try {
    await invoke("start_export", {
      projectDir: project.projectDir,
      options: {
        format: exportSettings.format,
        quality: exportSettings.quality,
        width: exportSettings.resolution.width,
        height: exportSettings.resolution.height,
        fps: exportSettings.fps,
        outputPath: `${project.projectDir}/export.${exportSettings.format}`,
        includeCursor: true,
        includeWebcam: project.config.camera?.enabled ?? false,
        includeMicAudio: true,
        includeSystemAudio: true,
      },
    });
    setExportState("complete");
  } catch (e) {
    setExportState("error");
  } finally {
    unlisten();
  }
};
```

---

## MVP Scope (Phase A)

For the first implementation, limit scope to:

1. **Screen video only** (no webcam compositing)
2. **Audio mixing** (mic + system)
3. **Basic cursor overlay** (draw cursor image on frames)
4. **MP4 output only**
5. **No zoom/time scaling**

This gets a working export pipeline. Additional features can be added incrementally.

---

## Technical Decisions

### Frame-by-Frame vs FFmpeg Filters

**Chosen: Frame-by-frame in Rust**

Pros:

- Full control over cursor positioning
- Can add click indicators, effects
- Consistent with existing capture pattern
- Easier to debug

Cons:

- Slower than pure FFmpeg filters
- More memory usage

### Video Decoding

Use FFmpeg to decode input video frames:

```bash
ffmpeg -i screen.mp4 -f rawvideo -pix_fmt rgba -
```

Read raw frames from stdout, composite, pipe to encoder.

---

## Verification Steps

1. **Unit tests:**
   - `cargo test` in `src-tauri/src/export/`
   - Test FFmpeg command generation
   - Test cursor position interpolation

2. **Integration test:**

   ```bash
   bun run tauri:dev
   ```

   - Make a short recording (~5 seconds)
   - Go to Export tab
   - Select "Web HD" preset
   - Click Export
   - Verify progress updates
   - Verify output file exists and plays correctly
   - Verify cursor is visible in exported video

3. **Manual verification:**
   - Play exported video in VLC/QuickTime
   - Check cursor movement matches preview
   - Check audio is present and synced

---

## Implementation Order

1. Create `src-tauri/src/export/mod.rs` and `types.rs`
2. Create `ffmpeg.rs` - encoder wrapper
3. Create `pipeline.rs` - basic screen+audio export (no cursor yet)
4. Create `commands/export.rs` and wire up
5. Update frontend to use real commands
6. Test basic export works
7. Add cursor overlay compositing
8. Add webcam overlay (Phase B)
9. Add WebM/GIF formats (Phase B)
10. Add zoom/time effects (Phase B)

---

## Dependencies

No new crates needed. Uses existing:

- `std::process::Command` for FFmpeg
- `serde` for types
- `tokio` for async
- `tauri` for commands/events
