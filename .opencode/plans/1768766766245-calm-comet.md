# Fix Audio/Video Preview Sync

## Current Status

- **Export:** Fixed - audio/video are in sync
- **Preview:** Still broken - audio is ~1 second behind video

## Root Cause Analysis

### Why Export Works

The export uses FFmpeg which muxes video and audio tracks together. FFmpeg aligns them based on their durations and the timing we specify.

### Why Preview Doesn't Work

In preview, we play three separate HTML5 media elements:

1. `<video>` for screen recording
2. `<audio>` for microphone
3. `<audio>` for system audio

**The problem:** The audio files are genuinely shorter/delayed relative to video because:

1. **Recording startup delay:** Even with two-phase coordinator, the audio thread has overhead:
   - Thread spawn time
   - Device acquisition in the thread
   - cpal stream building
   - First audio callback latency
2. **The audio file starts later:** Video captures its first frame immediately in `start()`, but audio waits for the cpal callback which can take 100ms+ to fire.

3. **No timing metadata:** We don't record or use the actual start timestamps of each channel.

## Solution Options

### Option A: Add audio delay to video playback (Recommended)

Instead of trying to delay audio, we can start the video slightly ahead and sync audio to catch up.

The key insight: if audio starts ~1 second late in the recording, we need to either:

- Delay video by ~1 second, OR
- Skip ahead in audio by ~1 second (but audio doesn't have that content)

Since audio is shorter, we need to **delay the video start** relative to audio.

**Implementation:**

1. Store channel start timestamps during recording
2. Calculate the offset between video and audio start times
3. Apply this offset in preview playback

### Option B: Calculate offset from file durations (Simpler)

If video is 10 seconds and audio is 9 seconds, the audio started 1 second late.
Use this offset to delay video playback.

**Implementation:**

1. When loading recording bundle, compare video duration to audio duration
2. The difference is the audio start delay
3. When playing, delay video by this amount OR start audio from a negative position (impossible) OR accept the offset and just sync continuously

### Option C: Continuous sync with offset compensation

Keep the current `syncAudio()` approach but add an offset:

- `audio.currentTime = video.currentTime - offset`

Where offset is calculated from duration differences.

## Recommended Approach: Option C (Simplest)

**Changes needed:**

1. **Calculate audio offset when loading:**

   ```typescript
   // In EditorView.tsx when loading recording bundle
   const videoLen = bundle.videoMetadata.durationMs;
   const micAudioDuration = // get from audio element or metadata
   const audioOffset = (videoLen - micAudioDuration) / 1000; // in seconds
   ```

2. **Apply offset in syncAudio:**

   ```typescript
   const syncAudio = useCallback(() => {
     if (!videoRef.current) return;
     const videoTime = videoRef.current.currentTime;

     if (micAudioRef.current) {
       // Audio started late, so it should be at (videoTime - offset)
       const targetTime = Math.max(0, videoTime - micAudioOffset);
       const diff = Math.abs(micAudioRef.current.currentTime - targetTime);
       if (diff > 0.02) {
         micAudioRef.current.currentTime = targetTime;
       }
     }
     // Same for system audio
   }, [micAudioOffset, systemAudioOffset]);
   ```

3. **Get audio durations:**
   Use the `loadedmetadata` event on audio elements to get their duration, then calculate offset.

## Files to Modify

| File                                   | Change                                        |
| -------------------------------------- | --------------------------------------------- |
| `src/components/editor/EditorView.tsx` | Add offset calculation and apply in syncAudio |

## Implementation Details

```typescript
// State for audio offsets
const [micAudioOffset, setMicAudioOffset] = useState(0);
const [systemAudioOffset, setSystemAudioOffset] = useState(0);

// Calculate offset when audio metadata loads
const handleMicAudioLoaded = useCallback(() => {
  if (micAudioRef.current && recordingBundle) {
    const videoDuration = recordingBundle.videoMetadata.durationMs / 1000;
    const audioDuration = micAudioRef.current.duration;
    // If video is longer than audio, audio started late
    const offset = videoDuration - audioDuration;
    setMicAudioOffset(offset > 0 ? offset : 0);
    console.log(`Mic audio offset: ${offset}s`);
  }
}, [recordingBundle]);

// Updated syncAudio
const syncAudio = useCallback(() => {
  if (!videoRef.current) return;
  const videoTime = videoRef.current.currentTime;

  if (micAudioRef.current) {
    // Audio started late, so at video time T, audio should be at T - offset
    const targetTime = Math.max(0, videoTime - micAudioOffset);
    const diff = Math.abs(micAudioRef.current.currentTime - targetTime);
    if (diff > 0.02) {
      micAudioRef.current.currentTime = targetTime;
    }
  }

  if (systemAudioRef.current) {
    const targetTime = Math.max(0, videoTime - systemAudioOffset);
    const diff = Math.abs(systemAudioRef.current.currentTime - targetTime);
    if (diff > 0.02) {
      systemAudioRef.current.currentTime = targetTime;
    }
  }
}, [micAudioOffset, systemAudioOffset]);

// Audio elements with onLoadedMetadata
<audio
  ref={micAudioRef}
  src={micAudioSrc}
  preload="auto"
  onLoadedMetadata={handleMicAudioLoaded}
>
```

## Verification

1. Record a video with audio (clap test)
2. Open in editor/preview
3. Play and verify audio syncs with video
4. Seek to different positions and verify sync holds
5. Verify export still works correctly
