# Phase 4: Webcam Recording - Bug Fix Plan

## Problem

Webcam recording only captures ~1.6fps instead of 30fps. From logs:

```
Webcam captured 13 frames in 8.14s (1.6 fps actual)
```

**Root Cause:** The `decode_image::<RgbAFormat>()` call performs CPU-intensive YUYV→RGBA conversion for 1920x1080 frames, taking ~600ms per frame instead of ~33ms.

## Solution

**Don't decode frames in Rust - let FFmpeg handle the conversion.**

Instead of:

1. Camera outputs YUYV frames
2. nokhwa decodes YUYV → RGBA (SLOW - 600ms)
3. FFmpeg encodes RGBA → H.264

Do this:

1. Camera outputs YUYV frames
2. Pass raw YUYV directly to FFmpeg
3. FFmpeg converts YUYV → YUV420P → H.264 (FAST - hardware accelerated)

## Files to Modify

| File                                    | Changes                                      |
| --------------------------------------- | -------------------------------------------- |
| `src-tauri/src/capture/macos/webcam.rs` | Pass raw YUYV to FFmpeg, update pixel format |

## Implementation

### Change 1: Update FFmpegWebcamEncoder

Change pixel format from `rgba` to `yuyv422`:

```rust
"-pixel_format", "yuyv422",  // Native camera format
```

### Change 2: Update capture loop

Don't decode, just pass raw buffer:

```rust
match camera.frame() {
    Ok(frame) => {
        // Don't decode - pass raw YUYV buffer directly
        let raw_data = frame.buffer();
        encoder.write_frame(raw_data);
    }
}
```

## Verification

1. Run `bun run tauri:dev`
2. Enable camera and start recording for ~7 seconds
3. Check logs show ~30fps actual capture rate
4. Verify webcam video plays at correct speed and matches screen recording duration

---

# Original Plan (Completed)

## Overview

**Goal:** Add camera/webcam recording channel for face-cam overlay in recordings  
**Platform:** macOS first (using AVFoundation), Windows later  
**Dependencies:** Existing RecordingChannel infrastructure from Phase 1-2

---

## Current State

### What Exists

- Type definitions in Rust (`CameraInfo`, `Resolution`, `CameraConfig`)
- Type definitions in TypeScript (`CameraPosition`, `WebcamChannelConfig`)
- UI scaffolding in `RecordingToolbar.tsx` (camera toggle, dropdown placeholder)
- `ChannelType::Webcam` enum variant
- `RecordingConfig` has `capture_webcam` and `webcam_device_id` fields

### What's Missing

- `WebcamCaptureChannel` implementation
- macOS AVFoundation webcam capture (`capture/macos/webcam.rs`)
- `get_cameras` Tauri command for device enumeration
- Camera permission handling
- Frontend camera device population

---

## Implementation Plan

### Step 1: Add Camera Permissions (macOS)

**File:** `src-tauri/src/capture/macos/permissions.rs`

Add camera permission functions alongside existing screen capture permissions:

```rust
pub fn check_camera_permission() -> bool {
    // AVCaptureDevice.authorizationStatus(for: .video) == .authorized
}

pub fn request_camera_permission() {
    // AVCaptureDevice.requestAccess(for: .video)
}
```

### Step 2: Camera Device Enumeration

**File:** `src-tauri/src/capture/macos/webcam.rs` (new)

```rust
pub fn get_cameras() -> Vec<CameraInfo> {
    // Use AVCaptureDevice.devices(for: .video)
    // Map to CameraInfo structs
}
```

**File:** `src-tauri/src/commands/system.rs`

Add command:

```rust
#[tauri::command]
pub fn get_cameras() -> Result<Vec<CameraInfo>, String>
```

### Step 3: WebcamCaptureChannel (macOS)

**File:** `src-tauri/src/capture/macos/webcam.rs`

Implement `RecordingChannel` trait:

| Method         | Description                                                           |
| -------------- | --------------------------------------------------------------------- |
| `initialize()` | Set up output path, session index                                     |
| `start()`      | Create AVCaptureSession, configure input/output, start FFmpeg encoder |
| `stop()`       | Stop capture session, finalize video file                             |
| `pause()`      | Pause capture                                                         |
| `resume()`     | Resume with new session index                                         |

**Key Components:**

- `AVCaptureSession` - manages capture flow
- `AVCaptureDeviceInput` - camera device input
- `AVCaptureVideoDataOutput` - frame delivery
- FFmpeg encoding via existing `FFmpegSegmentEncoder` pattern

**Output:** `recording-{session}-webcam.mp4`

### Step 4: Integration with Coordinator

**File:** `src-tauri/src/commands/recording.rs`

In `start_recording`, add webcam channel when `config.capture_webcam`:

```rust
if config.capture_webcam {
    let webcam_channel = WebcamCaptureChannel::new(
        "webcam".to_string(),
        config.webcam_device_id.clone(),
        width,
        height,
        fps,
    )?;
    channels.push(Box::new(webcam_channel));
}
```

### Step 5: Frontend Camera Selection

**File:** `src/components/recording/RecordingToolbar.tsx`

- Load cameras via `invoke("get_cameras")`
- Populate camera dropdown
- Store selected camera ID in state
- Pass to `start_recording`

---

## Files to Create

| File                                    | Description                               |
| --------------------------------------- | ----------------------------------------- |
| `src-tauri/src/capture/macos/webcam.rs` | macOS webcam capture + device enumeration |

## Files to Modify

| File                                            | Changes                           |
| ----------------------------------------------- | --------------------------------- |
| `src-tauri/src/capture/macos/mod.rs`            | Add `pub mod webcam;`             |
| `src-tauri/src/capture/macos/permissions.rs`    | Add camera permission functions   |
| `src-tauri/src/commands/system.rs`              | Add `get_cameras` command         |
| `src-tauri/src/commands/recording.rs`           | Add webcam channel to coordinator |
| `src-tauri/src/lib.rs`                          | Register `get_cameras` command    |
| `src/components/recording/RecordingToolbar.tsx` | Populate camera dropdown          |

---

## Technical Details

### AVFoundation Camera Capture

```rust
// Pseudocode for macOS implementation
let session = AVCaptureSession::new();
session.set_session_preset(AVCaptureSessionPreset1280x720);

let device = AVCaptureDevice::default_video_device();
let input = AVCaptureDeviceInput::new(device);
session.add_input(input);

let output = AVCaptureVideoDataOutput::new();
output.set_sample_buffer_delegate(handler, queue);
session.add_output(output);

session.start_running();
```

### Frame Callback → FFmpeg

```rust
// In sample buffer delegate callback
fn did_output_sample_buffer(&self, buffer: CMSampleBuffer) {
    // Extract pixel buffer
    let pixel_buffer = buffer.get_image_buffer();

    // Get raw bytes (BGRA)
    let base_address = CVPixelBufferGetBaseAddress(pixel_buffer);
    let data = slice::from_raw_parts(base_address, width * height * 4);

    // Send to FFmpeg encoder stdin
    encoder.write_frame(data);
}
```

### FFmpeg Webcam Encoding

```bash
ffmpeg -f rawvideo -pix_fmt bgra -s 1280x720 -r 30 -i - \
  -c:v libx264 -preset veryfast -crf 18 -pix_fmt yuv420p \
  output-webcam.mp4
```

---

## Dependencies

### Rust Crates (already available)

- `objc2-av-foundation` - AVFoundation bindings
- `objc2-core-video` - CVPixelBuffer handling
- `objc2-core-media` - CMSampleBuffer handling

### Check if additional features needed in Cargo.toml

---

## Verification Steps

### 1. Device Enumeration

```bash
# In dev tools console
await __TAURI__.invoke("get_cameras")
# Should return array of camera devices
```

### 2. Recording Integration

1. Enable camera toggle in UI
2. Start recording
3. Verify `recording-0-webcam.mp4` created in output dir
4. Check video plays and shows webcam content

### 3. Full Test

1. Start recording with display + audio + webcam
2. Stop recording
3. Verify all output files exist:
   - `recording-0.mp4` (screen)
   - `recording-0-mic.m4a` (if mic enabled)
   - `recording-0-system.m4a` (if system audio enabled)
   - `recording-0-webcam.mp4` (webcam)

---

## Future Enhancements (Not in MVP)

- Live camera preview in UI
- Camera resolution/FPS selection
- Mirror toggle
- Background blur/replacement
- Windows support via Media Foundation
